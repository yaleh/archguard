# Mermaid Diagram éªŒè¯ä¸è´¨é‡ä¿éšœæ–¹æ¡ˆ

**åˆ›å»ºæ—¥æœŸ**: 2026-01-26
**åˆ†æç›®æ ‡**: è®¾è®¡å¤šå±‚éªŒè¯ç­–ç•¥ï¼Œç¡®ä¿ç”Ÿæˆçš„ Mermaid diagram è¯­æ³•æ­£ç¡®ä¸”å¯æ¸²æŸ“
**åŸºäº**: åœ¨çº¿æœç´¢ã€å®˜æ–¹æ–‡æ¡£ã€GitHub Issuesã€æœ€ä½³å®è·µè°ƒç ”

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

ä¸ºäº†ç¡®ä¿ ArchGuard ç”Ÿæˆçš„ Mermaid diagram è¯­æ³•æ­£ç¡®ä¸”å¯æ¸²æŸ“ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ª**äº”å±‚éªŒè¯ç­–ç•¥**ï¼Œä»è¯­æ³•æ£€æŸ¥åˆ°å¤æ‚åº¦åˆ†æï¼Œå…¨æ–¹ä½ä¿éšœè´¨é‡ã€‚

### æ ¸å¿ƒç­–ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éªŒè¯å±‚ 1: è¯­æ³•ç”Ÿæˆé˜¶æ®µï¼ˆç¡®å®šæ€§ç”Ÿæˆï¼‰                           â”‚
â”‚   ä¸¥æ ¼çš„ä»£ç ç”Ÿæˆè§„åˆ™ï¼Œé¿å…å¸¸è§é”™è¯¯æ¨¡å¼                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éªŒè¯å±‚ 2: å³æ—¶éªŒè¯ï¼ˆmermaid.parseï¼‰                          â”‚
â”‚   ä½¿ç”¨å®˜æ–¹ API è¿›è¡Œè¯­æ³•éªŒè¯ï¼Œä¸æ¸²æŸ“                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éªŒè¯å±‚ 3: ç»“æ„å®Œæ•´æ€§æ£€æŸ¥ï¼ˆAST åˆ†æï¼‰                         â”‚
â”‚   æ£€æŸ¥å®ä½“å¼•ç”¨ã€å…³ç³»å®Œæ•´æ€§ã€å‘½åç©ºé—´è§„åˆ™                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éªŒè¯å±‚ 4: æ¸²æŸ“éªŒè¯ï¼ˆisomorphic-mermaidï¼‰                     â”‚
â”‚   å®é™…æ¸²æŸ“æµ‹è¯•ï¼Œç¡®ä¿å¯ä»¥ç”Ÿæˆ SVG                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éªŒè¯å±‚ 5: è´¨é‡åˆ†æï¼ˆMermaid-Sonarï¼‰                         â”‚
â”‚   å¯è¯»æ€§ã€å¤æ‚åº¦ã€æœ€ä½³å®è·µæ£€æŸ¥                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å½“å‰ï¼ˆPlantUMLï¼‰ | æ”¹è¿› |
|------|------|----------------|------|
| **è¯­æ³•é”™è¯¯ç‡** | < 1% | 40-60% | **-98%** |
| **æ¸²æŸ“æˆåŠŸç‡** | > 99% | 40-60% | **+65%** |
| **é¦–æ¬¡é€šè¿‡ç‡** | > 95% | ~5% | **+90%** |
| **é‡è¯•æ¬¡æ•°** | < 0.1 | 2-3 æ¬¡ | **-95%** |

---

## 1. å¸¸è§é”™è¯¯æ¨¡å¼åˆ†æ

### 1.1 Mermaid classDiagram å·²çŸ¥é™åˆ¶

åŸºäº [GitHub Issues è°ƒç ”](https://github.com/mermaid-js/mermaid/issues/4656)ï¼Œä»¥ä¸‹æ˜¯ Mermaid classDiagram çš„å·²çŸ¥é™åˆ¶ï¼š

#### é”™è¯¯æ¨¡å¼ 1: åµŒå¥— Namespace

```mermaid
âŒ é”™è¯¯ï¼šåµŒå¥— namespace å¯¼è‡´è§£æé”™è¯¯
namespace Outer {
  namespace Inner {
    class A { }
  }
}

âœ… æ­£ç¡®ï¼šå¹³çº§ namespace
namespace Outer {
  class A { }
}

namespace Inner {
  class B { }
}
```

**å‚è€ƒ**: [Issue #4618](https://github.com/mermaid-js/mermaid/issues/4618), [Issue #6085](https://github.com/mermaid-js/mermaid/issues/6085)

#### é”™è¯¯æ¨¡å¼ 2: Namespace å†…å®šä¹‰å…³ç³»

```mermaid
âŒ é”™è¯¯ï¼šåœ¨ namespace å†…éƒ¨å®šä¹‰å…³ç³»
namespace A {
  class X
  class Y
  X --> Y  // âŒ ä¸æ”¯æŒ
}

âœ… æ­£ç¡®ï¼šåœ¨ namespace å¤–éƒ¨å®šä¹‰å…³ç³»
namespace A {
  class X
}

namespace B {
  class Y
}

X --> Y  // âœ… æ­£ç¡®
```

**å‚è€ƒ**: [Issue #4656](https://github.com/mermaid-js/mermaid/issues/4656), [StackOverflow è®¨è®º](https://stackoverflow.com/questions/79469404/how-do-i-refer-to-a-namespace-in-a-relationship)

#### é”™è¯¯æ¨¡å¼ 3: æ³›å‹åœ¨ Namespace ä¸­

```mermaid
âŒ é”™è¯¯ï¼šæ³›å‹åœ¨ namespace ä¸­å¯¼è‡´é”™è¯¯
namespace A {
  class List~T~  // âŒ æŸäº›ç‰ˆæœ¬ä¸æ”¯æŒ
}

âœ… æ­£ç¡®ï¼šç®€åŒ–ç±»å‹å®šä¹‰
namespace A {
  class List  // âœ… ä¸ä½¿ç”¨æ³›å‹
}
```

**å‚è€ƒ**: [Issue #4578](https://github.com/mermaid-js/mermaid/issues/4578)

#### é”™è¯¯æ¨¡å¼ 4: æ³¨é‡Šåœ¨ Namespace ä¸­

```mermaid
âŒ é”™è¯¯ï¼šåœ¨ namespace ä¸­çš„ç±»ä¸Šæ·»åŠ æ³¨é‡Š
namespace A {
  class B
  note for B "Note"  // âŒ ä¸æ”¯æŒ
}

âœ… æ­£ç¡®ï¼šåœ¨ namespace å¤–éƒ¨æ·»åŠ æ³¨é‡Š
namespace A {
  class B
}

note for B "Note"  // âœ… æ­£ç¡®
```

**å‚è€ƒ**: [Issue #4706](https://github.com/mermaid-js/mermaid/issues/4706)

#### é”™è¯¯æ¨¡å¼ 5: é€—å·æ³›å‹

```mermaid
âŒ é”™è¯¯ï¼šä½¿ç”¨é€—å·åˆ†éš”çš„æ³›å‹
class Map~K, V~  // âŒ Mermaid ä¸æ”¯æŒ

âœ… æ­£ç¡®ï¼šç§»é™¤é€—å·
class Map~KV~  // âœ… åˆå¹¶ç±»å‹å
```

**å‚è€ƒ**: [å®˜æ–¹æ–‡æ¡£](https://mermaid.ai/open-source/syntax/classDiagram.html)

### 1.2 è¯­æ³•è§„åˆ™æ€»ç»“

| è§„åˆ™ | æè¿° | å¼ºåˆ¶æ€§ |
|------|------|--------|
| **ç¦æ­¢åµŒå¥— namespace** | namespace ä¸èƒ½åµŒå¥— | âœ… å¿…é¡» |
| **å…³ç³»åœ¨å¤–éƒ¨å®šä¹‰** | æ‰€æœ‰å…³ç³»å¿…é¡»åœ¨ namespace å¤–éƒ¨ | âœ… å¿…é¡» |
| **æ³›å‹æ— é€—å·** | `Map<K, V>` â†’ `Map~KV~` | âœ… å¿…é¡» |
| **ç±»åè½¬ä¹‰** | ç§»é™¤ `<` `>` `,` ç©ºæ ¼ | âœ… å¿…é¡» |
| **æ³¨é‡Šåœ¨å¤–éƒ¨** | note for å¿…é¡»åœ¨ namespace å¤–éƒ¨ | âš ï¸ å»ºè®® |
| **ç®€å• namespace** | é¿å…è¿‡åº¦å¤æ‚çš„åµŒå¥—ç»“æ„ | âš ï¸ å»ºè®® |

---

## 2. äº”å±‚éªŒè¯ç­–ç•¥è®¾è®¡

### éªŒè¯å±‚ 1: è¯­æ³•ç”Ÿæˆé˜¶æ®µï¼ˆç¡®å®šæ€§ç”Ÿæˆï¼‰

**ç›®æ ‡**: é€šè¿‡ä¸¥æ ¼çš„ä»£ç ç”Ÿæˆè§„åˆ™ï¼Œé¿å…å¸¸è§é”™è¯¯

#### å®ç°æ–¹æ¡ˆ

```typescript
// src/mermaid/generator-validated.ts

export class ValidatedMermaidGenerator extends MermaidGenerator {
  /**
   * ç”Ÿæˆæ—¶éªŒè¯è§„åˆ™
   */
  protected validateBeforeGenerate(): void {
    // è§„åˆ™ 1: æ£€æŸ¥ namespace åµŒå¥—
    this.checkNoNestedNamespaces();

    // è§„åˆ™ 2: æ£€æŸ¥å®ä½“åç§°
    this.validateEntityNames();

    // è§„åˆ™ 3: æ£€æŸ¥å…³ç³»å®šä¹‰
    this.validateRelationships();
  }

  /**
   * è§„åˆ™ 1: ç¦æ­¢åµŒå¥— namespace
   */
  private checkNoNestedNamespaces(): void {
    const namespaceTree = this.buildNamespaceTree();

    for (const pkg of this.options.grouping.packages) {
      if (pkg.name.includes('.')) {
        throw new GeneratorError(
          `Nested namespace detected: ${pkg.name}. ` +
          `Please use flat namespace structure.`
        );
      }
    }
  }

  /**
   * è§„åˆ™ 2: éªŒè¯å®ä½“åç§°
   */
  private validateEntityNames(): void {
    for (const entity of this.archJson.entities) {
      // æ£€æŸ¥éæ³•å­—ç¬¦
      const invalidChars = /[<>,"\s]/;
      if (invalidChars.test(entity.name)) {
        const sanitized = this.escapeId(entity.name);
        console.warn(
          `âš ï¸  Entity "${entity.name}" contains invalid characters. ` +
          `Will be sanitized to "${sanitized}"`
        );
      }

      // æ£€æŸ¥ä¿ç•™å­—
      const reservedWords = ['class', 'namespace', 'note', 'end'];
      if (reservedWords.includes(entity.name.toLowerCase())) {
        throw new GeneratorError(
          `Entity name "${entity.name}" is a reserved word`
        );
      }
    }
  }

  /**
   * è§„åˆ™ 3: éªŒè¯å…³ç³»
   */
  private validateRelationships(): void {
    for (const rel of this.archJson.relations) {
      const source = this.archJson.entities.find(e => e.id === rel.source);
      const target = this.archJson.entities.find(e => e.id === rel.target);

      // æ£€æŸ¥å®ä½“æ˜¯å¦å­˜åœ¨
      if (!source) {
        throw new GeneratorError(`Relation source not found: ${rel.source}`);
      }
      if (!target) {
        throw new GeneratorError(`Relation target not found: ${rel.target}`);
      }

      // æ£€æŸ¥è‡ªå¼•ç”¨
      if (rel.source === rel.target) {
        console.warn(`âš ï¸  Self-referencing relation: ${source.name}`);
      }
    }
  }

  /**
   * é‡å†™ generate() æ–¹æ³•ï¼Œæ·»åŠ ç”Ÿæˆå‰éªŒè¯
   */
  generate(): string {
    // ç”Ÿæˆå‰éªŒè¯
    this.validateBeforeGenerate();

    // è°ƒç”¨çˆ¶ç±»ç”Ÿæˆ
    const mermaidCode = super.generate();

    // ç”Ÿæˆåæ¸…ç†
    return this.postProcess(mermaidCode);
  }

  /**
   * ç”Ÿæˆåå¤„ç†
   */
  private postProcess(code: string): string {
    let cleaned = code;

    // æ¸…ç† 1: ç§»é™¤å¤šä½™ç©ºè¡Œ
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');

    // æ¸…ç† 2: ç¡®ä¿æ¢è¡Œç¬¦ç»Ÿä¸€
    cleaned = cleaned.replace(/\r\n/g, '\n');

    // æ¸…ç† 3: ç§»é™¤æœ«å°¾ç©ºè¡Œ
    cleaned = cleaned.trim();

    return cleaned;
  }
}
```

**æ”¶ç›Š**:
- âœ… åœ¨ç”Ÿæˆé˜¶æ®µæ•è· 80% çš„é”™è¯¯
- âœ… æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
- âœ… è‡ªåŠ¨ä¿®å¤å¸¸è§é—®é¢˜

---

### éªŒè¯å±‚ 2: å³æ—¶éªŒè¯ï¼ˆmermaid.parseï¼‰

**ç›®æ ‡**: ä½¿ç”¨å®˜æ–¹ API è¿›è¡Œè¯­æ³•éªŒè¯ï¼Œä¸æ¸²æŸ“

**å·¥å…·**: [`mermaid.parse()`](https://mermaid.ai/open-source/config/usage.html)

#### å®ç°æ–¹æ¡ˆ

```typescript
// src/mermaid/validator-parse.ts

import mermaid from 'isomorphic-mermaid';

export interface ParseValidationResult {
  valid: boolean;
  errors: ParseError[];
  warnings: string[];
}

export interface ParseError {
  message: string;
  line?: number;
  column?: number;
  suggestion?: string;
}

export class MermaidParseValidator {
  private initialized = false;

  constructor(private options: {
    suppressErrors?: boolean;
    timeout?: number;
  }) {}

  /**
   * ä½¿ç”¨ mermaid.parse() è¿›è¡Œè¯­æ³•éªŒè¯
   *
   * å…³é”®é…ç½®ï¼š
   * - suppressErrors: true (ä¸è¾“å‡ºé”™è¯¯åˆ°æ§åˆ¶å°)
   * - ä¸å®é™…æ¸²æŸ“ï¼Œåªæ£€æŸ¥è¯­æ³•
   */
  async validate(mermaidCode: string): Promise<ParseValidationResult> {
    this.ensureInitialized();

    const errors: ParseError[] = [];
    const warnings: string[] = [];

    try {
      // ä½¿ç”¨ mermaid.parse() åªéªŒè¯ï¼Œä¸æ¸²æŸ“
      await mermaid.parse(mermaidCode, {
        suppressErrors: true,  // ä¸è¾“å‡ºé”™è¯¯åˆ°æ§åˆ¶å°
      });

      return {
        valid: true,
        errors: [],
        warnings,
      };
    } catch (error) {
      return {
        valid: false,
        errors: this.parseError(error),
        warnings,
      };
    }
  }

  /**
   * è§£æ Mermaid é”™è¯¯ä¿¡æ¯
   */
  private parseError(error: Error): ParseError[] {
    const errors: ParseError[] = [];
    const message = error.message || error.toString();

    // é”™è¯¯æ¨¡å¼ 1: "str" é”™è¯¯ï¼ˆå­—ç¬¦ä¸²æ ¼å¼é—®é¢˜ï¼‰
    if (message.includes('str')) {
      errors.push({
        message: 'Invalid string format in diagram',
        suggestion: 'Check for unescaped quotes or special characters in class names or labels',
      });
    }

    // é”™è¯¯æ¨¡å¼ 2: "No diagram type detected"
    if (message.includes('No diagram type detected')) {
      errors.push({
        message: 'Missing diagram type declaration',
        suggestion: 'Add "classDiagram" at the beginning of the diagram',
      });
    }

    // é”™è¯¯æ¨¡å¼ 3: "Parse error"
    if (message.includes('Parse error')) {
      errors.push({
        message: 'Syntax error in diagram definition',
        suggestion: 'Check arrow syntax, relationship definitions, and namespace structure',
      });
    }

    // é”™è¯¯æ¨¡å¼ 4: "unknown diagram type"
    if (message.includes('unknown diagram type')) {
      errors.push({
        message: 'Invalid diagram type',
        suggestion: 'Use "classDiagram" for class diagrams',
      });
    }

    // é”™è¯¯æ¨¡å¼ 5: åŒ…å«è¡Œå·ä¿¡æ¯
    const lineMatch = message.match(/line\s+(\d+)/);
    if (lineMatch) {
      errors[0].line = parseInt(lineMatch[1], 10);
    }

    // å¦‚æœæ— æ³•è¯†åˆ«é”™è¯¯ï¼Œè¿”å›åŸå§‹æ¶ˆæ¯
    if (errors.length === 0) {
      errors.push({
        message: message.substring(0, 200),  // é™åˆ¶é•¿åº¦
        suggestion: 'Please check the Mermaid syntax documentation',
      });
    }

    return errors;
  }

  /**
   * æ‰¹é‡éªŒè¯å¤šä¸ªå›¾è¡¨
   */
  async validateBatch(mermaidCodes: string[]): Promise<ParseValidationResult[]> {
    return Promise.all(
      mermaidCodes.map(code => this.validate(code))
    );
  }

  private ensureInitialized(): void {
    if (!this.initialized) {
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'strict',
        logLevel: 'error',  // åªè¾“å‡ºé”™è¯¯
      });

      this.initialized = true;
    }
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```typescript
const validator = new MermaidParseValidator({
  suppressErrors: true,
});

const result = await validator.validate(mermaidCode);

if (!result.valid) {
  console.error('âŒ Validation failed:');
  for (const error of result.errors) {
    console.error(`  - ${error.message}`);
    if (error.suggestion) {
      console.error(`    ğŸ’¡ ${error.suggestion}`);
    }
  }
} else {
  console.log('âœ… Validation passed');
}
```

**ä¼˜åŠ¿**:
- âœ… å®˜æ–¹ APIï¼Œå¯é æ€§é«˜
- âœ… ä¸éœ€è¦æ¸²æŸ“ï¼Œå¿«é€Ÿ
- âœ… è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
- âœ… å¯ä»¥æ•è·æ‰€æœ‰è¯­æ³•é”™è¯¯

---

### éªŒè¯å±‚ 3: ç»“æ„å®Œæ•´æ€§æ£€æŸ¥ï¼ˆAST åˆ†æï¼‰

**ç›®æ ‡**: æ£€æŸ¥å®ä½“å¼•ç”¨ã€å…³ç³»å®Œæ•´æ€§ã€å‘½åç©ºé—´è§„åˆ™

#### å®ç°æ–¹æ¡ˆ

```typescript
// src/mermaid/validator-structural.ts

export class StructuralValidator {
  /**
   * éªŒè¯å›¾è¡¨ç»“æ„å®Œæ•´æ€§
   */
  validate(mermaidCode: string, archJson: ArchJSON): StructuralValidationResult {
    const issues: ValidationIssue[] = [];

    // æ£€æŸ¥ 1: å®ä½“å¼•ç”¨å®Œæ•´æ€§
    issues.push(...this.checkEntityReferences(mermaidCode, archJson));

    // æ£€æŸ¥ 2: å…³ç³»å¯¹ç§°æ€§
    issues.push(...this.checkRelationshipSymmetry(mermaidCode, archJson));

    // æ£€æŸ¥ 3: å‘½åç©ºé—´ä½¿ç”¨
    issues.push(...this.checkNamespaceUsage(mermaidCode, archJson));

    // æ£€æŸ¥ 4: å¾ªç¯ä¾èµ–
    issues.push(...this.checkCircularDependencies(archJson));

    // æ£€æŸ¥ 5: å­¤ç«‹å®ä½“
    issues.push(...this.checkOrphanedEntities(archJson));

    return {
      valid: issues.filter(i => i.severity === 'error').length === 0,
      issues,
    };
  }

  /**
   * æ£€æŸ¥ 1: å®ä½“å¼•ç”¨å®Œæ•´æ€§
   */
  private checkEntityReferences(
    mermaidCode: string,
    archJson: ArchJSON
  ): ValidationIssue[] {
    const issues: ValidationIssue[] = [];
    const definedClasses = new Set<string>();

    // æå–æ‰€æœ‰å®šä¹‰çš„ç±»
    const classMatches = mermaidCode.matchAll(/class\s+(\S+)/g);
    for (const match of classMatches) {
      definedClasses.add(match[1]);
    }

    // æ£€æŸ¥å…³ç³»ä¸­çš„å¼•ç”¨
    const relationMatches = mermaidCode.matchAll(/(\S+)\s+[\-*\.]+[>]*\s+(\S+)/g);
    for (const match of relationMatches) {
      const [, from, to] = match;

      if (!definedClasses.has(from)) {
        issues.push({
          severity: 'error',
          type: 'undefined-entity',
          message: `Undefined entity in relation: ${from}`,
          entity: from,
        });
      }

      if (!definedClasses.has(to)) {
        issues.push({
          severity: 'error',
          type: 'undefined-entity',
          message: `Undefined entity in relation: ${to}`,
          entity: to,
        });
      }
    }

    return issues;
  }

  /**
   * æ£€æŸ¥ 2: å…³ç³»å¯¹ç§°æ€§
   */
  private checkRelationshipSymmetry(
    mermaidCode: string,
    archJson: ArchJSON
  ): ValidationIssue[] {
    const issues: ValidationIssue[] = [];
    const relationships = new Map<string, string>();

    for (const rel of archJson.relations) {
      const source = archJson.entities.find(e => e.id === rel.source);
      const target = archJson.entities.find(e => e.id === rel.target);

      if (!source || !target) continue;

      const key = `${source.name}-${target.name}`;

      // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åæ–¹å‘çš„å…³ç³»
      const reverseKey = `${target.name}-${source.name}`;
      if (relationships.has(reverseKey)) {
        const existingType = relationships.get(reverseKey);

        // æ£€æŸ¥æ˜¯å¦æœ‰çŸ›ç›¾çš„å…³ç³»ç±»å‹
        if (this.isContradictory(rel.type, existingType!)) {
          issues.push({
            severity: 'warning',
            type: 'contradictory-relationship',
            message: `Contradictory relationships between ${source.name} and ${target.name}`,
            entities: [source.name, target.name],
          });
        }
      }

      relationships.set(key, rel.type);
    }

    return issues;
  }

  /**
   * æ£€æŸ¥ 3: å‘½åç©ºé—´ä½¿ç”¨
   */
  private checkNamespaceUsage(
    mermaidCode: string,
    archJson: ArchJSON
  ): ValidationIssue[] {
    const issues: ValidationIssue[] = [];

    // æ£€æŸ¥æ˜¯å¦åœ¨ namespace å†…éƒ¨å®šä¹‰äº†å…³ç³»
    const lines = mermaidCode.split('\n');
    let inNamespace = false;
    let namespaceDepth = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      if (line.startsWith('namespace ')) {
        inNamespace = true;
        namespaceDepth++;
      } else if (line === '}') {
        namespaceDepth--;
        if (namespaceDepth === 0) {
          inNamespace = false;
        }
      } else if (inNamespace && this.isRelationshipLine(line)) {
        issues.push({
          severity: 'error',
          type: 'relationship-in-namespace',
          message: `Relationship defined inside namespace at line ${i + 1}`,
          line: i + 1,
          suggestion: 'Move all relationships outside namespace blocks',
        });
      }
    }

    return issues;
  }

  /**
   * æ£€æŸ¥ 4: å¾ªç¯ä¾èµ–
   */
  private checkCircularDependencies(archJson: ArchJSON): ValidationIssue[] {
    const issues: ValidationIssue[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const detectCycle = (entityId: string): boolean => {
      if (recursionStack.has(entityId)) {
        return true;  // å‘ç°å¾ªç¯
      }

      if (visited.has(entityId)) {
        return false;  // å·²æ£€æŸ¥è¿‡
      }

      visited.add(entityId);
      recursionStack.add(entityId);

      const entity = archJson.entities.find(e => e.id === entityId);
      if (!entity) return false;

      // æŸ¥æ‰¾æ‰€æœ‰ä¾èµ–
      const dependencies = archJson.relations
        .filter(r => r.source === entityId)
        .map(r => r.target);

      for (const dep of dependencies) {
        if (detectCycle(dep)) {
          return true;
        }
      }

      recursionStack.delete(entityId);
      return false;
    };

    for (const entity of archJson.entities) {
      if (!visited.has(entity.id)) {
        if (detectCycle(entity.id)) {
          issues.push({
            severity: 'warning',
            type: 'circular-dependency',
            message: `Circular dependency detected involving ${entity.name}`,
            entity: entity.name,
            suggestion: 'Consider restructuring to break the cycle',
          });
        }
      }
    }

    return issues;
  }

  /**
   * æ£€æŸ¥ 5: å­¤ç«‹å®ä½“
   */
  private checkOrphanedEntities(archJson: ArchJSON): ValidationIssue[] {
    const issues: ValidationIssue[] = [];
    const connectedEntities = new Set<string>();

    // æ”¶é›†æ‰€æœ‰æœ‰å…³ç³»çš„å®ä½“
    for (const rel of archJson.relations) {
      connectedEntities.add(rel.source);
      connectedEntities.add(rel.target);
    }

    // æŸ¥æ‰¾å­¤ç«‹å®ä½“
    for (const entity of archJson.entities) {
      if (!connectedEntities.has(entity.id)) {
        issues.push({
          severity: 'info',
          type: 'orphaned-entity',
          message: `Entity ${entity.name} has no relationships`,
          entity: entity.name,
          suggestion: 'This is acceptable for top-level entities',
        });
      }
    }

    return issues;
  }

  // ========== è¾…åŠ©æ–¹æ³• ==========

  private isRelationshipLine(line: string): boolean {
    return /[-->|<|--|*--|o--|\.\.|>]/.test(line);
  }

  private isContradictory(type1: RelationType, type2: RelationType): boolean {
    // ç»§æ‰¿å’Œå®ç°ä¸èƒ½åŒæ—¶å­˜åœ¨
    if ((type1 === 'inheritance' && type2 === 'implementation') ||
        (type1 === 'implementation' && type2 === 'inheritance')) {
      return true;
    }

    return false;
  }
}
```

**ä¼˜åŠ¿**:
- âœ… æ•è·è¯­ä¹‰é”™è¯¯ï¼ˆä¸æ˜¯è¯­æ³•é”™è¯¯ï¼‰
- âœ… æ£€æŸ¥æ¶æ„è®¾è®¡é—®é¢˜
- âœ… æä¾›æ”¹è¿›å»ºè®®
- âœ… ä¸ä¾èµ– Mermaid è§£æå™¨

---

### éªŒè¯å±‚ 4: æ¸²æŸ“éªŒè¯ï¼ˆisomorphic-mermaidï¼‰

**ç›®æ ‡**: å®é™…æ¸²æŸ“æµ‹è¯•ï¼Œç¡®ä¿å¯ä»¥ç”Ÿæˆ SVG

#### å®ç°æ–¹æ¡ˆ

```typescript
// src/mermaid/validator-render.ts

import mermaid from 'isomorphic-mermaid';

export class RenderValidator {
  private initialized = false;

  /**
   * å®é™…æ¸²æŸ“æµ‹è¯•
   */
  async validateRender(mermaidCode: string): Promise<RenderValidationResult> {
    this.ensureInitialized();

    try {
      // å°è¯•å®é™…æ¸²æŸ“
      const { svg } = await mermaid.render('render-test', mermaidCode);

      // éªŒè¯ SVG è¾“å‡º
      if (!svg || svg.length === 0) {
        return {
          valid: false,
          error: 'Generated SVG is empty',
        };
      }

      // éªŒè¯ SVG æ ¼å¼
      if (!svg.includes('<svg') || !svg.includes('</svg>')) {
        return {
          valid: false,
          error: 'Invalid SVG format generated',
        };
      }

      // æ£€æŸ¥ SVG å¤§å°ï¼ˆåˆç†æ€§æ£€æŸ¥ï¼‰
      const sizeMatch = svg.match(/viewBox="([^"]+)"/);
      if (sizeMatch) {
        const [, viewBox] = sizeMatch;
        const [width, height] = viewBox.split(' ').slice(2).map(Number);

        if (width > 50000 || height > 50000) {
          return {
            valid: false,
            error: `SVG too large: ${width}x${height}`,
            warning: 'Consider simplifying the diagram',
          };
        }
      }

      return {
        valid: true,
        svg,
        stats: {
          svgSize: svg.length,
          width: this.extractSVGSize(svg, 'width'),
          height: this.extractSVGSize(svg, 'height'),
        },
      };
    } catch (error) {
      return {
        valid: false,
        error: error.message,
        suggestion: this.suggestFix(error),
      };
    }
  }

  /**
   * æ‰¹é‡æ¸²æŸ“éªŒè¯
   */
  async validateBatch(mermaidCodes: string[]): Promise<RenderValidationResult[]> {
    return Promise.all(
      mermaidCodes.map(code => this.validateRender(code))
    );
  }

  /**
   * æå–ä¿®å¤å»ºè®®
   */
  private suggestFix(error: Error): string {
    const message = error.message.toLowerCase();

    if (message.includes('maximum call stack')) {
      return 'Possible circular reference in relationships';
    }

    if (message.includes('out of memory')) {
      return 'Diagram too complex, consider reducing entities or relationships';
    }

    if (message.includes('timeout')) {
      return 'Rendering timeout, diagram may be too complex';
    }

    return 'Check Mermaid syntax and diagram complexity';
  }

  private extractSVGSize(svg: string, dimension: 'width' | 'height'): number {
    const match = svg.match(new RegExp(`${dimension}="(\\d+)"`));
    return match ? parseInt(match[1], 10) : 0;
  }

  private ensureInitialized(): void {
    if (!this.initialized) {
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'strict',
        logLevel: 'error',
        maxTextSize: 50000,  // é˜²æ­¢è¿‡å¤§æ–‡æœ¬
        maxEdges: 500,       // é˜²æ­¢è¿‡å¤šå…³ç³»
      });

      this.initialized = true;
    }
  }
}
```

**ä¼˜åŠ¿**:
- âœ… 100% ç¡®è®¤å¯æ¸²æŸ“æ€§
- âœ… æ•è·è¿è¡Œæ—¶é”™è¯¯
- âœ… æ£€æŸ¥å¤æ‚åº¦é™åˆ¶
- âœ… æä¾›å®é™… SVG è¾“å‡º

---

### éªŒè¯å±‚ 5: è´¨é‡åˆ†æï¼ˆMermaid-Sonarï¼‰

**ç›®æ ‡**: å¯è¯»æ€§ã€å¤æ‚åº¦ã€æœ€ä½³å®è·µæ£€æŸ¥

**å‚è€ƒ**: [Mermaid-Sonar: Complexity Analyzer](https://entropicdrift.com/blog/mermaid-sonar-complexity-analyzer/)

#### å®ç°æ–¹æ¡ˆ

```typescript
// src/mermaid/validator-quality.ts

export interface QualityMetrics {
  readability: ReadabilityScore;
  complexity: ComplexityScore;
  bestPractices: BestPracticeCheck[];
}

export interface ReadabilityScore {
  score: number;  // 0-100
  issues: ReadabilityIssue[];
}

export interface ComplexityScore {
  score: number;  // 0-100 (higher is better)
  metrics: {
    entityCount: number;
    relationshipCount: number;
    averageRelationshipsPerEntity: number;
    maxDepth: number;
  };
}

export class QualityValidator {
  /**
   * åˆ†æå›¾è¡¨è´¨é‡
   */
  analyze(mermaidCode: string, archJson: ArchJSON): QualityMetrics {
    return {
      readability: this.analyzeReadability(mermaidCode, archJson),
      complexity: this.analyzeComplexity(archJson),
      bestPractices: this.checkBestPractices(mermaidCode, archJson),
    };
  }

  /**
   * å¯è¯»æ€§åˆ†æ
   */
  private analyzeReadability(
    mermaidCode: string,
    archJson: ArchJSON
  ): ReadabilityScore {
    const issues: ReadabilityIssue[] = [];
    let score = 100;

    // æ£€æŸ¥ 1: å®ä½“æ•°é‡
    if (archJson.entities.length > 30) {
      issues.push({
        type: 'too-many-entities',
        message: `${archJson.entities.length} entities may be overwhelming`,
        impact: -20,
        suggestion: 'Consider splitting into multiple diagrams or using package-level view',
      });
      score -= 20;
    }

    // æ£€æŸ¥ 2: å…³ç³»å¯†åº¦
    const relationshipDensity = archJson.relations.length / Math.max(archJson.entities.length, 1);
    if (relationshipDensity > 5) {
      issues.push({
        type: 'high-relationship-density',
        message: `Average ${relationshipDensity.toFixed(1)} relationships per entity`,
        impact: -15,
        suggestion: 'Consider showing only key relationships or using multiple diagrams',
      });
      score -= 15;
    }

    // æ£€æŸ¥ 3: åç§°é•¿åº¦
    const longNames = archJson.entities.filter(e => e.name.length > 30);
    if (longNames.length > 0) {
      issues.push({
        type: 'long-names',
        message: `${longNames.length} entities with names > 30 characters`,
        impact: -5,
        suggestion: 'Use shorter, more concise names',
      });
      score -= 5;
    }

    // æ£€æŸ¥ 4: å‘½åç©ºé—´ä½¿ç”¨
    if (this.options.grouping.packages.length === 1 && archJson.entities.length > 15) {
      issues.push({
        type: 'missing-organization',
        message: 'Many entities without namespace grouping',
        impact: -10,
        suggestion: 'Consider using namespaces to organize entities',
      });
      score -= 10;
    }

    return {
      score: Math.max(0, score),
      issues,
    };
  }

  /**
   * å¤æ‚åº¦åˆ†æ
   */
  private analyzeComplexity(archJson: ArchJSON): ComplexityScore {
    const entityCount = archJson.entities.length;
    const relationshipCount = archJson.relations.length;
    const avgRelsPerEntity = relationshipCount / Math.max(entityCount, 1);

    // è®¡ç®—æœ€å¤§æ·±åº¦ï¼ˆä¾èµ–æ·±åº¦ï¼‰
    const maxDepth = this.calculateMaxDepth(archJson);

    // å¤æ‚åº¦åˆ†æ•°ï¼ˆè¶Šä½è¶Šå¤æ‚ï¼‰
    const complexityScore = 100 - (
      Math.min(entityCount, 50) * 1 +      // å®ä½“æ•°é‡å½±å“
      Math.min(relationshipCount, 100) * 0.5 +  // å…³ç³»æ•°é‡å½±å“
      maxDepth * 5 +                      // æ·±åº¦å½±å“
      (avgRelsPerEntity > 3 ? 20 : 0)     // å…³ç³»å¯†åº¦å½±å“
    );

    return {
      score: Math.max(0, complexityScore),
      metrics: {
        entityCount,
        relationshipCount,
        averageRelationshipsPerEntity: avgRelsPerEntity,
        maxDepth,
      },
    };
  }

  /**
   * æœ€ä½³å®è·µæ£€æŸ¥
   */
  private checkBestPractices(
    mermaidCode: string,
    archJson: ArchJSON
  ): BestPracticeCheck[] {
    const checks: BestPracticeCheck[] = [];

    // æ£€æŸ¥ 1: ä½¿ç”¨ namespace
    checks.push({
      name: 'Uses namespaces',
      passed: this.options.grouping.packages.length > 1,
      description: 'Organize entities into namespaces for better readability',
    });

    // æ£€æŸ¥ 2: æ–¹å‘ä¸€è‡´
    const hasDirection = mermaidCode.includes('direction');
    checks.push({
      name: 'Has explicit direction',
      passed: hasDirection,
      description: 'Specify diagram direction for predictable layout',
    });

    // æ£€æŸ¥ 3: é¿å…è¿‡åº¦è¿æ¥
    const overlyConnected = archJson.entities.filter(e => {
      const relCount = archJson.relations.filter(
        r => r.source === e.id || r.target === e.id
      ).length;
      return relCount > 10;
    });

    checks.push({
      name: 'No overly connected entities',
      passed: overlyConnected.length === 0,
      description: 'Entities with >10 relationships may indicate need for refactoring',
    });

    // æ£€æŸ¥ 4: é€‚å½“çš„è¯¦ç»†ç¨‹åº¦
    const hasMethods = archJson.entities.some(e =>
      e.members.some(m => m.type === 'method')
    );

    checks.push({
      name: 'Appropriate detail level',
      passed: this.options.level === 'class' || !hasMethods,
      description: 'Method-level details should only be shown when specifically needed',
    });

    return checks;
  }

  /**
   * è®¡ç®—æœ€å¤§ä¾èµ–æ·±åº¦
   */
  private calculateMaxDepth(archJson: ArchJSON): number {
    const visited = new Set<string>();

    const getDepth = (entityId: string, currentDepth = 0): number => {
      if (visited.has(entityId)) {
        return currentDepth;  // é˜²æ­¢å¾ªç¯
      }

      visited.add(entityId);

      const dependencies = archJson.relations
        .filter(r => r.source === entityId)
        .map(r => r.target);

      if (dependencies.length === 0) {
        return currentDepth;
      }

      return 1 + Math.max(...dependencies.map(dep => getDepth(dep, currentDepth + 1)));
    };

    let maxDepth = 0;
    for (const entity of archJson.entities) {
      visited.clear();
      const depth = getDepth(entity.id);
      maxDepth = Math.max(maxDepth, depth);
    }

    return maxDepth;
  }
}
```

**ä¼˜åŠ¿**:
- âœ… è¯„ä¼°å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
- âœ… æä¾›æ”¹è¿›å»ºè®®
- âœ… å¸®åŠ©ä¼˜åŒ–å›¾è¡¨ç»“æ„
- âœ… ç¬¦åˆæœ€ä½³å®è·µ

---

## 3. ç»¼åˆéªŒè¯ç®¡é“

### 3.1 å®Œæ•´éªŒè¯æµç¨‹

```typescript
// src/mermaid/validation-pipeline.ts

export class MermaidValidationPipeline {
  private parseValidator: MermaidParseValidator;
  private structuralValidator: StructuralValidator;
  private renderValidator: RenderValidator;
  private qualityValidator: QualityValidator;

  constructor(private options: ValidationOptions) {
    this.parseValidator = new MermaidParseValidator(options);
    this.structuralValidator = new StructuralValidator();
    this.renderValidator = new RenderValidator();
    this.qualityValidator = new QualityValidator(options);
  }

  /**
   * å®Œæ•´éªŒè¯æµç¨‹
   */
  async validateFull(
    mermaidCode: string,
    archJson: ArchJSON
  ): Promise<ValidationReport> {
    const report: ValidationReport = {
      timestamp: new Date().toISOString(),
      mermaidCode,
      stages: [],
      overallValid: true,
    };

    // é˜¶æ®µ 1: è¯­æ³•éªŒè¯
    console.log('ğŸ” Stage 1: Parse validation...');
    const parseResult = await this.parseValidator.validate(mermaidCode);
    report.stages.push({ name: 'parse', result: parseResult });

    if (!parseResult.valid) {
      report.overallValid = false;
      return report;
    }

    // é˜¶æ®µ 2: ç»“æ„éªŒè¯
    console.log('ğŸ” Stage 2: Structural validation...');
    const structuralResult = this.structuralValidator.validate(mermaidCode, archJson);
    report.stages.push({ name: 'structural', result: structuralResult });

    if (!structuralResult.valid) {
      report.overallValid = false;
      // ç»§ç»­æ‰§è¡Œï¼Œæ”¶é›†æ‰€æœ‰é”™è¯¯
    }

    // é˜¶æ®µ 3: æ¸²æŸ“éªŒè¯
    console.log('ğŸ” Stage 3: Render validation...');
    const renderResult = await this.renderValidator.validateRender(mermaidCode);
    report.stages.push({ name: 'render', result: renderResult });

    if (!renderResult.valid) {
      report.overallValid = false;
      return report;  // æ¸²æŸ“å¤±è´¥ï¼Œç»ˆæ­¢
    }

    // é˜¶æ®µ 4: è´¨é‡åˆ†æ
    console.log('ğŸ” Stage 4: Quality analysis...');
    const qualityResult = this.qualityValidator.analyze(mermaidCode, archJson);
    report.stages.push({ name: 'quality', result: qualityResult });

    return report;
  }

  /**
   * å¿«é€ŸéªŒè¯ï¼ˆä»…è¯­æ³•ï¼‰
   */
  async validateQuick(mermaidCode: string): Promise<boolean> {
    const result = await this.parseValidator.validate(mermaidCode);
    return result.valid;
  }

  /**
   * ç”ŸæˆéªŒè¯æŠ¥å‘Š
   */
  generateReport(report: ValidationReport): string {
    const lines: string[] = [];

    lines.push('# Mermaid Validation Report');
    lines.push(`Generated: ${report.timestamp}`);
    lines.push('');

    for (const stage of report.stages) {
      lines.push(`## ${stage.name.toUpperCase()}`);

      if (stage.name === 'parse') {
        const result = stage.result as ParseValidationResult;
        if (result.valid) {
          lines.push('âœ… PASSED');
        } else {
          lines.push('âŒ FAILED');
          lines.push('');
          for (const error of result.errors) {
            lines.push(`- ${error.message}`);
            if (error.suggestion) {
              lines.push(`  ğŸ’¡ ${error.suggestion}`);
            }
          }
        }
      }

      if (stage.name === 'structural') {
        const result = stage.result as StructuralValidationResult;
        lines.push(`Issues: ${result.issues.length}`);
        for (const issue of result.issues) {
          lines.push(`  [${issue.severity}] ${issue.message}`);
        }
      }

      if (stage.name === 'render') {
        const result = stage.result as RenderValidationResult;
        if (result.valid) {
          lines.push(`âœ… PASSED (SVG: ${result.stats.svgSize} bytes)`);
        } else {
          lines.push(`âŒ FAILED: ${result.error}`);
        }
      }

      if (stage.name === 'quality') {
        const result = stage.result as QualityMetrics;
        lines.push(`Readability: ${result.readability.score}/100`);
        lines.push(`Complexity: ${result.complexityScore.score}/100`);
        lines.push(`Best Practices: ${result.bestPractices.filter(p => p.passed).length}/${result.bestPractices.length} passed`);
      }

      lines.push('');
    }

    return lines.join('\n');
  }
}
```

### 3.2 ä½¿ç”¨ç¤ºä¾‹

```typescript
// åœ¨ MermaidDiagramGenerator ä¸­ä½¿ç”¨
export class MermaidDiagramGenerator {
  async generateAndRender(archJson: ArchJSON, options: GenerateOptions) {
    // 1. ç”Ÿæˆ Mermaid ä»£ç 
    const generator = new ValidatedMermaidGenerator(archJson, options);
    const mermaidCode = generator.generate();

    // 2. éªŒè¯
    const pipeline = new MermaidValidationPipeline(options);
    const report = await pipeline.validateFull(mermaidCode, archJson);

    // 3. å¤„ç†éªŒè¯ç»“æœ
    if (!report.overallValid) {
      console.error('âŒ Validation failed:');
      console.error(pipeline.generateReport(report));

      // å°è¯•è‡ªåŠ¨ä¿®å¤
      const repaired = await this.attemptRepair(mermaidCode, report);
      if (repaired) {
        console.log('âœ… Repaired successfully');
        mermaidCode = repaired;
      } else {
        throw new Error('Validation failed and cannot be repaired');
      }
    }

    // 4. æ¸²æŸ“
    const renderer = new IsomorphicMermaidRenderer();
    await renderer.renderAndSave(mermaidCode, outputPaths);

    // 5. è¾“å‡ºè´¨é‡æŠ¥å‘Š
    console.log('ğŸ“Š Quality Report:');
    const qualityStage = report.stages.find(s => s.name === 'quality');
    if (qualityStage) {
      const metrics = qualityStage.result as QualityMetrics;
      console.log(`  Readability: ${metrics.readability.score}/100`);
      console.log(`  Complexity: ${metrics.complexityScore.score}/100`);
    }
  }

  /**
   * è‡ªåŠ¨ä¿®å¤
   */
  private async attemptRepair(
    mermaidCode: string,
    report: ValidationReport
  ): Promise<string | null> {
    let repaired = mermaidCode;

    // ä¿®å¤ 1: æ·»åŠ  classDiagram å£°æ˜
    const parseStage = report.stages.find(s => s.name === 'parse');
    if (parseStage && !(parseStage.result as ParseValidationResult).valid) {
      if (!repaired.includes('classDiagram')) {
        repaired = 'classDiagram\n' + repaired;
      }
    }

    // ä¿®å¤ 2: ç§»é™¤é€—å·æ³›å‹
    repaired = repaired.replace(/<([^>]+),\s*([^>]*)>/g, '~$1$2~');

    // ä¿®å¤ 3: è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
    repaired = repaired.replace(/[<>]/g, '_');

    // éªŒè¯ä¿®å¤ç»“æœ
    const parseResult = await this.parseValidator.validate(repaired);
    if (parseResult.valid) {
      return repaired;
    }

    return null;
  }
}
```

---

## 4. æµ‹è¯•ç­–ç•¥

### 4.1 å•å…ƒæµ‹è¯•

```typescript
// tests/unit/mermaid/validation-pipeline.test.ts

describe('MermaidValidationPipeline', () => {
  const pipeline = new MermaidValidationPipeline({});

  describe('Stage 1: Parse validation', () => {
    it('should detect missing classDiagram', async () => {
      const invalidCode = 'class A { +method() }';
      const result = await pipeline.validateQuick(invalidCode);

      expect(result).toBe(false);
    });

    it('should accept valid classDiagram', async () => {
      const validCode = `
        classDiagram
          class A {
            +method()
          }
      `;
      const result = await pipeline.validateQuick(validCode);

      expect(result).toBe(true);
    });
  });

  describe('Stage 2: Structural validation', () => {
    it('should detect undefined entity references', () => {
      const archJson = createMockArchJSON();
      const mermaidCode = 'A --> B';  // B æœªå®šä¹‰

      const result = pipeline.structuralValidator.validate(mermaidCode, archJson);

      expect(result.valid).toBe(false);
      expect(result.issues).toContainEqual(
        expect.objectContaining({ type: 'undefined-entity' })
      );
    });
  });

  describe('Stage 3: Render validation', () => {
    it('should successfully render valid diagram', async () => {
      const validCode = `
        classDiagram
          class A {
            +method()
          }
      `;

      const result = await pipeline.renderValidator.validateRender(validCode);

      expect(result.valid).toBe(true);
      expect(result.svg).toContain('<svg');
    });

    it('should detect circular dependencies', () => {
      const archJson = createCircularDependencyArchJSON();

      const result = pipeline.structuralValidator.validate('', archJson);

      expect(result.issues).toContainEqual(
        expect.objectContaining({ type: 'circular-dependency' })
      );
    });
  });

  describe('Stage 4: Quality analysis', () => {
    it('should detect too many entities', () => {
      const archJson = createLargeArchJSON(50);  // 50 ä¸ªå®ä½“

      const metrics = pipeline.qualityValidator.analyze('', archJson);

      expect(metrics.readability.score).toBeLessThan(80);
      expect(metrics.readability.issues).toContainEqual(
        expect.objectContaining({ type: 'too-many-entities' })
      );
    });
  });
});
```

### 4.2 é›†æˆæµ‹è¯•

```typescript
// tests/integration/mermaid/generation-validation.test.ts

describe('Mermaid Generation & Validation', () => {
  it('should generate valid Mermaid from ArchJSON', async () => {
    // 1. åˆ›å»ºæµ‹è¯• ArchJSON
    const archJson = createTestArchJSON();

    // 2. ç”Ÿæˆ Mermaid
    const generator = new ValidatedMermaidGenerator(archJson, {
      level: 'class',
      grouping: createTestGrouping(),
    });

    const mermaidCode = generator.generate();

    // 3. éªŒè¯
    const pipeline = new MermaidValidationPipeline({});
    const report = await pipeline.validateFull(mermaidCode, archJson);

    expect(report.overallValid).toBe(true);
  });

  it('should handle complex real-world project', async () => {
    // ä½¿ç”¨ ArchGuard è‡ªå·±çš„ä»£ç ä½œä¸ºæµ‹è¯•
    const archJson = await parseTypeScriptProject('./src');

    const generator = new ValidatedMermaidGenerator(archJson, {
      level: 'class',
      grouping: await heuristicGrouper.group(archJson),
    });

    const mermaidCode = generator.generate();

    const report = await pipeline.validateFull(mermaidCode, archJson);

    expect(report.overallValid).toBe(true);

    // è´¨é‡æ£€æŸ¥
    const qualityStage = report.stages.find(s => s.name === 'quality');
    const metrics = qualityStage.result as QualityMetrics;

    expect(metrics.readability.score).toBeGreaterThan(60);
    expect(metrics.complexityScore.score).toBeGreaterThan(40);
  });
});
```

### 4.3 å›å½’æµ‹è¯•

```typescript
// tests/regression/mermaid-known-errors.test.ts

describe('Mermaid Known Error Patterns', () => {
  const errorPatterns = [
    {
      name: 'Nested namespace',
      code: `
        classDiagram
          namespace Outer {
            namespace Inner {
              class A { }
            }
          }
      `,
      shouldFail: true,
    },
    {
      name: 'Relationship in namespace',
      code: `
        classDiagram
          namespace A {
            class X
            class Y
            X --> Y
          }
      `,
      shouldFail: true,
    },
    {
      name: 'Comma generic',
      code: `
        classDiagram
          class Map~K, V~
      `,
      shouldFail: true,
    },
  ];

  for (const pattern of errorPatterns) {
    it(`should detect error: ${pattern.name}`, async () => {
      const result = await pipeline.validateQuick(pattern.code);

      if (pattern.shouldFail) {
        expect(result).toBe(false);
      } else {
        expect(result).toBe(true);
      }
    });
  }
});
```

---

## 5. æ€§èƒ½ä¼˜åŒ–

### 5.1 å¢é‡éªŒè¯

```typescript
export class IncrementalValidator {
  private cache = new Map<string, ValidationReport>();

  /**
   * å¢é‡éªŒè¯ï¼šåªéªŒè¯å˜æ›´éƒ¨åˆ†
   */
  async validateIncremental(
    mermaidCode: string,
    archJson: ArchJSON,
    previousReport?: ValidationReport
  ): Promise<ValidationReport> {
    // è®¡ç®—ä»£ç å“ˆå¸Œ
    const hash = this.computeHash(mermaidCode);

    // å¦‚æœæœªå˜æ›´ï¼Œè¿”å›ç¼“å­˜ç»“æœ
    if (this.cache.has(hash)) {
      return this.cache.get(hash)!;
    }

    // æ‰§è¡Œå®Œæ•´éªŒè¯
    const pipeline = new MermaidValidationPipeline({});
    const report = await pipeline.validateFull(mermaidCode, archJson);

    // ç¼“å­˜ç»“æœ
    this.cache.set(hash, report);

    return report;
  }

  private computeHash(code: string): string {
    return require('crypto')
      .createHash('sha256')
      .update(code)
      .digest('hex');
  }
}
```

### 5.2 å¹¶è¡ŒéªŒè¯

```typescript
export class ParallelValidator {
  /**
   * å¹¶è¡ŒéªŒè¯å¤šä¸ªå›¾è¡¨
   */
  async validateBatchParallel(
    mermaidCodes: string[],
    archJsons: ArchJSON[]
  ): Promise<ValidationReport[]> {
    const concurrency = 4;  // å¹¶å‘æ•°
    const results: ValidationReport[] = [];

    for (let i = 0; i < mermaidCodes.length; i += concurrency) {
      const batch = mermaidCodes.slice(i, i + concurrency);
      const batchReports = await Promise.all(
        batch.map((code, idx) =>
          this.validateFull(code, archJsons[i + idx])
        )
      );

      results.push(...batchReports);
    }

    return results;
  }
}
```

---

## 6. ç›‘æ§å’ŒæŠ¥å‘Š

### 6.1 éªŒè¯æŒ‡æ ‡

```typescript
export interface ValidationMetrics {
  totalGenerated: number;
  validationPassed: number;
  validationFailed: number;
  autoRepaired: number;
  averageQualityScore: number;
  errorDistribution: Record<string, number>;
}

export class ValidationMonitor {
  private metrics: ValidationMetrics = {
    totalGenerated: 0,
    validationPassed: 0,
    validationFailed: 0,
    autoRepaired: 0,
    averageQualityScore: 0,
    errorDistribution: {},
  };

  recordValidation(report: ValidationReport): void {
    this.metrics.totalGenerated++;

    if (report.overallValid) {
      this.metrics.validationPassed++;
    } else {
      this.metrics.validationFailed++;

      // è®°å½•é”™è¯¯ç±»å‹
      for (const stage of report.stages) {
        if (stage.name === 'parse') {
          const result = stage.result as ParseValidationResult;
          for (const error of result.errors) {
            const errorType = error.message.split(':')[0];
            this.metrics.errorDistribution[errorType] =
              (this.metrics.errorDistribution[errorType] || 0) + 1;
          }
        }
      }
    }

    // è®°å½•è´¨é‡åˆ†æ•°
    const qualityStage = report.stages.find(s => s.name === 'quality');
    if (qualityStage) {
      const metrics = qualityStage.result as QualityMetrics;
      this.metrics.averageQualityScore =
        (this.metrics.averageQualityScore * (this.metrics.totalGenerated - 1) +
          metrics.readability.score) / this.metrics.totalGenerated;
    }
  }

  getMetrics(): ValidationMetrics {
    return { ...this.metrics };
  }

  printReport(): void {
    console.log('ğŸ“Š Validation Metrics:');
    console.log(`  Total Generated: ${this.metrics.totalGenerated}`);
    console.log(`  Passed: ${this.metrics.validationPassed} (${(this.metrics.validationPassed / this.metrics.totalGenerated * 100).toFixed(1)}%)`);
    console.log(`  Failed: ${this.metrics.validationFailed}`);
    console.log(`  Avg Quality Score: ${this.metrics.averageQualityScore.toFixed(1)}/100`);
    console.log('');
    console.log('Error Distribution:');
    for (const [error, count] of Object.entries(this.metrics.errorDistribution)) {
      console.log(`  ${error}: ${count}`);
    }
  }
}
```

---

## 7. æ€»ç»“

### 7.1 éªŒè¯ç­–ç•¥å¯¹æ¯”

| ç»´åº¦ | å½“å‰ï¼ˆPlantUMLï¼‰ | æ–°æ–¹æ¡ˆï¼ˆMermaidï¼‰ | æ”¹è¿› |
|------|----------------|------------------|------|
| **è¯­æ³•é”™è¯¯ç‡** | 40-60% | <1% | **-98%** |
| **é¦–æ¬¡é€šè¿‡ç‡** | ~5% | >95% | **+90%** |
| **é‡è¯•æ¬¡æ•°** | 2-3 æ¬¡ | <0.1 æ¬¡ | **-95%** |
| **é”™è¯¯å®šä½** | æ¨¡ç³Š | ç²¾ç¡®ï¼ˆè¡Œå·ï¼‰ | **100x** |
| **è‡ªåŠ¨ä¿®å¤** | æ—  | æœ‰ | **âˆ** |

### 7.2 å…³é”®æ”¶ç›Š

1. **âœ… è¯­æ³•æ­£ç¡®æ€§**: äº”å±‚éªŒè¯ç¡®ä¿ç”Ÿæˆçš„ä»£ç  100% å¯æ¸²æŸ“
2. **âœ… å¿«é€Ÿåé¦ˆ**: å³æ—¶éªŒè¯ï¼Œæ— éœ€ç­‰å¾…å¤–éƒ¨æ¸²æŸ“
3. **âœ… è¯¦ç»†é”™è¯¯**: ç²¾ç¡®å®šä½é—®é¢˜ï¼Œæä¾›ä¿®å¤å»ºè®®
4. **âœ… è‡ªåŠ¨ä¿®å¤**: å¸¸è§é”™è¯¯è‡ªåŠ¨ä¿®å¤
5. **âœ… è´¨é‡ä¿éšœ**: å¤æ‚åº¦å’Œå¯è¯»æ€§åˆ†æ

### 7.3 å®æ–½ä¼˜å…ˆçº§

| ä¼˜å…ˆçº§ | ç»„ä»¶ | æ—¶é—´ | æ”¶ç›Š |
|-------|------|------|------|
| P0 | ValidatedMermaidGenerator | 1 å¤© | é¿å…ç”Ÿæˆé”™è¯¯ |
| P0 | MermaidParseValidator | 1 å¤© | è¯­æ³•éªŒè¯ |
| P0 | RenderValidator | 1 å¤© | æ¸²æŸ“éªŒè¯ |
| P1 | StructuralValidator | 2 å¤© | è¯­ä¹‰æ£€æŸ¥ |
| P1 | ValidationPipeline | 1 å¤© | ç»Ÿä¸€æµç¨‹ |
| P2 | QualityValidator | 2 å¤© | è´¨é‡åˆ†æ |
| P2 | ValidationMonitor | 1 å¤© | ç›‘æ§æŒ‡æ ‡ |

**æ€»è®¡**: 9-11 å¤©

---

## Sources

- [MCP Mermaid Validator](https://github.com/rtuin/mcp-mermaid-validator)
- [Mermaid Parse API Usage](https://mermaid.ai/open-source/config/usage.html)
- [GitHub Issue #4656 - Relationships in namespaces](https://github.com/mermaid-js/mermaid/issues/4656)
- [GitHub Issue #4578 - Generic class syntax](https://github.com/mermaid-js/mermaid/issues/4578)
- [GitHub Issue #4618 - Nested namespace parse error](https://github.com/mermaid-js/mermaid/issues/4618)
- [GitHub Issue #4706 - Notes for namespaced classes](https://github.com/mermaid-js/mermaid/issues/4706)
- [Mermaid-Sonar Complexity Analyzer](https://entropicdrift.com/blog/mermaid-sonar-complexity-analyzer/)
- [Automatically Fix AI Generated Mermaid Diagrams](https://medium.com/@gregoriomomm/automatically-fix-ai-generated-mermaid-diagrams-ee2472b98a80)
- [I Built an AI Mermaid Diagram Generator That Fixes Its Own Mistakes](https://djajafer.medium.com/i-built-an-ai-mermaid-diagram-generator-that-fixes-its-own-mistakes-26552047c37a)

import fs from 'fs-extra';
import * as path from 'path';
import type { Config } from '../types.js';
import type { BatchResult } from './batch-processor.js';

export class IndexGenerator {
  constructor(private config: Config) {}

  async generate(results: BatchResult[]): Promise<void> {
    const indexPath = path.join(this.config.outputDir!, 'index.md');
    const content = this.buildIndexContent(results);

    await fs.ensureDir(this.config.outputDir!);
    await fs.writeFile(indexPath, content, 'utf-8');
  }

  private buildIndexContent(results: BatchResult[]): string {
    const timestamp = new Date().toISOString();
    const successful = results.filter((r) => r.success);
    const failed = results.filter((r) => !r.success);

    let content = '# Architecture Diagrams Index\n\n';
    content += `**Generated**: ${timestamp}\n`;
    content += `**Total Modules**: ${results.length} (${successful.length} successful, ${failed.length} failed)\n\n`;
    content += '---\n\n';

    // Modules section
    content += '## Modules\n\n';
    for (const result of successful) {
      content += `### ${result.moduleName}\n\n`;
      content += `- **Source**: \`${result.sourcePath}\`\n`;
      content += `- **Entities**: ${result.entities || 0}\n`;
      content += `- **Relations**: ${result.relations || 0}\n`;
      content += `- **Complexity**: ${this.calculateComplexity(result)}\n`;

      if (result.pngPath) {
        const relativePath = path.relative(this.config.outputDir!, result.pngPath);
        content += `- **Diagram**: [View PNG](${relativePath})\n\n`;
        content += `![${result.moduleName}](${relativePath})\n\n`;
      } else if (result.outputPath) {
        const relativePath = path.relative(this.config.outputDir!, result.outputPath);
        content += `- **Diagram**: [View PlantUML](${relativePath})\n\n`;
      }

      content += '---\n\n';
    }

    // Summary statistics
    content += '## Summary Statistics\n\n';
    content += `- **Total Modules**: ${results.length}\n`;
    content += `- **Successful**: ${successful.length}\n`;
    content += `- **Failed**: ${failed.length}\n`;

    const totalEntities = successful.reduce((sum, r) => sum + (r.entities || 0), 0);
    const totalRelations = successful.reduce((sum, r) => sum + (r.relations || 0), 0);
    const avgEntities = successful.length > 0 ? totalEntities / successful.length : 0;
    const avgRelations = successful.length > 0 ? totalRelations / successful.length : 0;

    content += `- **Total Entities**: ${totalEntities}\n`;
    content += `- **Total Relations**: ${totalRelations}\n`;
    content += `- **Average Entities per Module**: ${avgEntities.toFixed(1)}\n`;
    content += `- **Average Relations per Module**: ${avgRelations.toFixed(1)}\n\n`;

    // Insights
    content += this.generateInsights(results);

    // Failed modules
    if (failed.length > 0) {
      content += '---\n\n';
      content += '## Failed Modules\n\n';
      for (const result of failed) {
        content += `### ${result.moduleName}\n\n`;
        content += `- **Source**: \`${result.sourcePath}\`\n`;
        content += `- **Error**: ${result.error}\n\n`;
      }
      content += '---\n\n';
    }

    content += '*Generated by ArchGuard v1.2.0*\n';

    return content;
  }

  private calculateComplexity(result: BatchResult): string {
    const entities = result.entities || 0;
    const relations = result.relations || 0;
    const score = entities + relations * 0.5;

    if (score < 20) return 'Low';
    if (score < 50) return 'Medium';
    if (score < 100) return 'High';
    return 'Very High';
  }

  private generateInsights(results: BatchResult[]): string {
    const successful = results.filter((r) => r.success);
    if (successful.length === 0) {
      return '';
    }

    let insights = '## Insights\n\n';

    // Find most complex module
    const mostComplex = successful.reduce((max, r) => {
      const maxScore = (max.entities || 0) + (max.relations || 0);
      const rScore = (r.entities || 0) + (r.relations || 0);
      return rScore > maxScore ? r : max;
    });
    insights += `- **Most Complex Module**: ${mostComplex.moduleName} (${mostComplex.entities || 0} entities, ${mostComplex.relations || 0} relations)\n`;

    // Find least complex module
    const leastComplex = successful.reduce((min, r) => {
      const minScore = (min.entities || 0) + (min.relations || 0);
      const rScore = (r.entities || 0) + (r.relations || 0);
      return rScore < minScore ? r : min;
    });
    insights += `- **Least Complex Module**: ${leastComplex.moduleName} (${leastComplex.entities || 0} entities, ${leastComplex.relations || 0} relations)\n`;

    // Average complexity
    const totalEntities = successful.reduce((sum, r) => sum + (r.entities || 0), 0);
    const avgEntities = totalEntities / successful.length;
    insights += `- **Average Complexity**: ${avgEntities.toFixed(1)} entities per module\n`;

    // Recommendation for high complexity modules
    const highComplexityModules = successful.filter((r) => (r.entities || 0) > 50);
    if (highComplexityModules.length > 0) {
      const moduleNames = highComplexityModules.map((r) => r.moduleName).join(', ');
      insights += `- **Recommendation**: Consider refactoring ${moduleNames} - high complexity detected\n`;
    }

    insights += '\n';
    return insights;
  }
}

/**
 * DiagramIndexGenerator - Generate index.md for multiple diagrams (v2.0)
 *
 * Creates a navigation page listing all generated diagrams with statistics
 * and quick access links.
 *
 * @module cli/utils/diagram-index-generator
 * @version 2.0.0
 */

import fs from 'fs-extra';
import path from 'path';
import type { DiagramResult } from '@/cli/processors/diagram-processor.js';
import type { GlobalConfig } from '@/types/config.js';

/**
 * IndexGenerator for v2.0 DiagramProcessor
 *
 * Generates index.md with:
 * - List of all diagrams with links
 * - Statistics (entities, relations, parse time)
 * - Failed diagrams section
 * - Summary statistics
 */
export class DiagramIndexGenerator {
  constructor(private globalConfig: GlobalConfig) {}

  /**
   * Generate index.md file
   *
   * @param results - Array of diagram results
   */
  async generate(results: DiagramResult[]): Promise<void> {
    const indexPath = path.join(this.globalConfig.outputDir, 'index.md');
    const content = this.buildIndexContent(results);

    await fs.ensureDir(this.globalConfig.outputDir);
    await fs.writeFile(indexPath, content, 'utf-8');
  }

  /**
   * Build markdown content for index
   */
  private buildIndexContent(results: DiagramResult[]): string {
    const timestamp = new Date().toISOString();
    const successful = results.filter((r) => r.success);
    const failed = results.filter((r) => !r.success);

    let content = '# Architecture Diagrams\n\n';
    content += `**Generated**: ${timestamp}\n`;
    content += `**Total Diagrams**: ${results.length}\n`;
    content += `**Successful**: ${successful.length}\n`;
    content += `**Failed**: ${failed.length}\n\n`;
    content += '---\n\n';

    // Successful diagrams section
    if (successful.length > 0) {
      content += '## Diagrams\n\n';
      for (const result of successful) {
        content += this.buildDiagramSection(result);
      }
    }

    // Summary statistics
    content += this.buildSummarySection(successful);

    // Failed diagrams section
    if (failed.length > 0) {
      content += this.buildFailedSection(failed);
    }

    content += '*Generated by ArchGuard v2.0*\n';

    return content;
  }

  /**
   * Build section for a single diagram
   */
  private buildDiagramSection(result: DiagramResult): string {
    let section = `### ${result.name}\n\n`;

    if (result.stats) {
      section += `- **Entities**: ${result.stats.entities}\n`;
      section += `- **Relations**: ${result.stats.relations}\n`;
      section += `- **Parse Time**: ${(result.stats.parseTime / 1000).toFixed(2)}s\n`;
    }

    // Add links to generated files
    if (result.paths) {
      if (result.paths.png) {
        const relativePath = path.relative(this.globalConfig.outputDir, result.paths.png);
        section += `- **Diagram**: [View PNG](${relativePath})\n\n`;
        section += `![${result.name}](${relativePath})\n\n`;
      } else if (result.paths.svg) {
        const relativePath = path.relative(this.globalConfig.outputDir, result.paths.svg);
        section += `- **Diagram**: [View SVG](${relativePath})\n\n`;
      } else if (result.paths.json) {
        const relativePath = path.relative(this.globalConfig.outputDir, result.paths.json);
        section += `- **Data**: [View JSON](${relativePath})\n\n`;
      } else if (result.paths.mmd) {
        const relativePath = path.relative(this.globalConfig.outputDir, result.paths.mmd);
        section += `- **Source**: [View Mermaid](${relativePath})\n\n`;
      }
    }

    section += '---\n\n';
    return section;
  }

  /**
   * Build summary statistics section
   */
  private buildSummarySection(successful: DiagramResult[]): string {
    if (successful.length === 0) {
      return '';
    }

    const totalEntities = successful.reduce((sum, r) => sum + (r.stats?.entities || 0), 0);
    const totalRelations = successful.reduce((sum, r) => sum + (r.stats?.relations || 0), 0);
    const totalTime = successful.reduce((sum, r) => sum + (r.stats?.parseTime || 0), 0);
    const avgEntities = totalEntities / successful.length;
    const avgRelations = totalRelations / successful.length;

    let section = '## Summary Statistics\n\n';
    section += `- **Total Entities**: ${totalEntities}\n`;
    section += `- **Total Relations**: ${totalRelations}\n`;
    section += `- **Total Parse Time**: ${(totalTime / 1000).toFixed(2)}s\n`;
    section += `- **Average Entities per Diagram**: ${avgEntities.toFixed(1)}\n`;
    section += `- **Average Relations per Diagram**: ${avgRelations.toFixed(1)}\n\n`;

    return section;
  }

  /**
   * Build failed diagrams section
   */
  private buildFailedSection(failed: DiagramResult[]): string {
    let section = '---\n\n';
    section += '## Failed Diagrams\n\n';

    for (const result of failed) {
      section += `### ${result.name}\n\n`;
      section += `- **Error**: ${result.error}\n\n`;
    }

    section += '---\n\n';
    return section;
  }
}
